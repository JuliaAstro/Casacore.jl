var documenterSearchIndex = {"docs":
[{"location":"#Casacore.jl","page":"Home","title":"Casacore.jl","text":"(Image: Test)\n\nThis package provides a Julia interface to the National Radio Astronomy Observatory (NRAO) casacore C++ library.\n\ncasacore is a popular library used primarily in radio astronomy. Amongst other things, its tables functionality is used to store and manipulate visibility data, whilst its measures interface allows for conversion between different reference frames based on ephemeris data.\n\nThe Casacore package depends on the casacorecxx and CxxWrap packages to provide a C interface to the casacore C++ library.\n\nThis package is still under development. Because casacore is a very large library, the Julia interface has been developed with specific use cases in mind, limited by the author's own experience. Issues and pull requests are very welcome to help expand on functionality and use cases.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"Casacore.jl is installable in the usual way:\n\n] add Casacore\n\nCasacore.jl will install all of its own dependencies including Casacore itself.\n\nCasacore.jl is limited to the currently supported architectures of casacore_jll.","category":"section"},{"location":"#Updating-the-ephemeris-data","page":"Home","title":"Updating the ephemeris data","text":"When installing Casacore.jl, the build step downloads and installs the latest ephemeris data for use in Casacore.Measures. To update this dataset with a later version, the build step can be manually rerun:\n\n] build Casacore","category":"section"},{"location":"#Casacore.Tables","page":"Home","title":"Casacore.Tables","text":"","category":"section"},{"location":"#Opening-and-creating-new-tables","page":"Home","title":"Opening and creating new tables","text":"Tables can be opened or created in the following way:\n\nusing Casacore.Tables: Tables, Table\n\n# Open existing table, read only\ntable = Table(\"/path/to/my/table.ms\", Tables.Old)\n\n# Open existing table, read/write\ntable = Table(\"/path/to/my/table.ms\", Tables.Update)\n\n# Create a new, empty table\ntable = Table(\"/path/to/my/table.ms\", Tables.New)\n\nOther TableOptions are listed below:\n\nTableOptions Description\nOld Open existing table read only\nUpdate Open existing table read/write\nNew Create new table\nNewNoReplace Create new table but error if it already exists\nScratch Create new table, but delete when it falls out of scope\n\nA table contains certain metadata about its size, columns and subtables:\n\n# Get table size\nsize(table) == (260000, 25)  # rows x columns\n# list of columns\nkeys(table) == (:UVW, :DATA, ...)\n# list of subtables\npropertynames(table) == (:ANTENNA, :FIELD, ...)","category":"section"},{"location":"#Adding/removing-rows","page":"Home","title":"Adding/removing rows","text":"Table rows can be added or removed using the resize!() function:\n\nsize(table) == (260000, 25)\n\n# Expand total rows to 300,000\n# New rows will be filled with default values\nresize!(table, 300000)\nsize(table) == (300000, 25)\n\n# Truncate number of rows\nresize!(table, 100000)\nsize(table) == (100000, 25)\n\nAdditionally, specific rows may be deleted using deleteat!():\n\n# Delete row 100\ndeleteat!(table, 100)\n\n# Delete every second row\ndeleteat!(table, 1:2:size(table, 1))","category":"section"},{"location":"#Subtables","page":"Home","title":"Subtables","text":"Subtables can be accessed as properties of the the Table object:\n\npropertynames(table)  # => (:ANTENNA, :FIELD, ...)\n\nsubtable = table.ANTENNA\n\nSubtables are opened with the same locking and write attributes as their parents.\n\nNew subtables can be added by simply assigning a new table object:\n\nsubtable = Table()  # with no path, creates a temporary table\nresize!(subtable, 128)  # set rows to 128\n\n# Add some columns to our table\nsubtable[:ID] = 1:128\nsubtable[:X] = rand(128)\nsubtable[:Y] = rand(128)\nsubtable[:Z] = rand(128)\n\n# Finally, set our table as a subtable\ntable.ANTENNA = subtable  # this results in a copy\n\nNote that the subtable is copied into the parent table, and future modifications to the subtable object in the example above will not affect table.ANTENNA.\n\nSubtables can be deleted using delete!():\n\ndelete!(table, :ANTENNA)","category":"section"},{"location":"#Columns","page":"Home","title":"Columns","text":"Columns are accessed as keys on Table objects:\n\nkeys(table)  # => [:UVW, :WEIGHT, :DATA, ...]\n\n# Load a column\nuvwcol = table[:UVW]  # <: Column{Float32, 2}\n\nLike native Array{T, N} types, columns also store their element type and dimensionality as Column{T, N}.\n\nCasacore allows for a range of column types, including some degenerative array columns with unknown shape or even unknown dimensionality. The below table lists these different types and their representation in Casacore.jl:\n\nName Description Type\nScalar Simple vector column Column{T, 1}\nFixed array Array column with known dimension and size Column{T, N}\nFixed dimension Array column with fixed dimension but variable size per row Column{Array{T, N - 1}, 1}\nFree array Array column unknown dimension and size Column{Array{T}, 1}","category":"section"},{"location":"#Column-Indexing","page":"Home","title":"Column Indexing","text":"Columns may be indexed to retrieve or set their data:\n\n# Retrieve data from column as Julia array\ndata = uvwcol[:, 1:100]  # Get the first 100 rows\n\n# Write to column\nuvwcol[:, 1:100] = rand(Float32, 3, 100)\n\nIndexing operations are limited to single values, unit ranges (e.g. 3:300), and colons. More complicated indexes such as with strided ranges (e.g. 1:2:100) or with bitmasks are not supported.\n\nA note on performance: whilst the Column{T, N} object provides an indexing interface, this is an expensive operation that involves searching and reading from the disk. We do not provide an iterable or AbstractArray interface to this object to discourage its use in this way. Instead, it is recommended to index from a Column{T, N} object infrequently, loading large amounts of data at a time, possibly using batching operations to manage memory usage.\n\nFor scalar columns and arrays with a fixed size, indexing operations and the resulting array types will be intuitive. For example:\n\nflags = table[:FLAG_ROW]  # <: Column{Bool, 1}\nsize(flags) == (260000,)\nflags[:] <: Vector{Bool}\n\ncorrected = table[:CORRECTED_DATA]  # <: Column{ComplexF64, 3}\nsize(corrected) == (4, 768, 260000)\ncorrected[:, 1:192, :] <: Array{ComplexF64, 3}\n\nColumns that do not have a fixed size will be typed as providing arrays of arrays. For example:\n\n# No fixed size, but known dimension per cell\nweightcol = table[:WEIGHT]  # <: Column{Vector{Float64}, 1}\nsize(weightcol) == (260000,)\nrow = weightcol[2] <: Vector{Float64}\nsize(row) == (4,)\n\nThese small array allocations for every row are not great for performance, but are required since we cannot know the size (and sometimes the dimension) of the rows ahead of time.\n\nAs a shorthand, the full contents of the array may be loaded using the empty index which can be useful for exploratory work without having to first check the dimensions of a column. For example:\n\ncorrected[] == corrected[:, :, :]\nweightcol[] == weightcol[:]","category":"section"},{"location":"#Forced-multidimensional-indexing","page":"Home","title":"Forced multidimensional indexing","text":"If you know that that your column with no fixed size actually contains constant-sized arrays, you can force Casacore to attempt to load these as one contiguous array:\n\ndata = weightcol[1:4, :]::Matrix{Float64}\n\nIn this example, we are telling Casacore that weightcol is 2-dimensional, and contains at least 4 values in each row. If these assumptions are not true, this will fail.","category":"section"},{"location":"#Adding/removing-columns","page":"Home","title":"Adding/removing columns","text":"","category":"section"},{"location":"#Explicit-construction","page":"Home","title":"Explicit construction","text":"Columns may be added in two ways. The first is by construction of a ColumnDesc object. When we assign this to the Table object, we cause the column to be created:\n\n# Create scalar column\ncoldesc = ScalarColumnDesc{Float64}(comment=\"My special data\")\ntable[:NEWCOL] = coldesc\ntypeof(table[:NEWCOL]) <: Column{Float64, 1}\n\n# Create array column, with each cell having 2 dimensions\n# and fixed shape\ncoldesc = ArrayColumnDesc{Int, 2}((4, 768))\ntable[:NEWCOL] = coldesc\ntypeof(table[:NEWCOL]) <: Column{Int, 3}\n\nNote that the dimensionality N of the ArrayColumnDesc{T, N} refers to the dimensionality of the cell. The dimensionality of the column additionally includes the rows.\n\nThe degenerate column types may also be created in this way:\n\n# Unknown size, known dimension\ncoldesc = ArrayColumnDesc{ComplexF64, 2}()\ntable[:NEWCOL] = coldesc\ntypeof(table[:NEWCOL]) <: Column{Array{ComplexF64, 2}, 1}\n\n# Unknown dimension and size\ncoldesc = ArrayColumnDesc{Int16}()\ntable[:NEWCOL] = coldesc\ntypeof(table[:NEWCOL]) <: Column{Array{Int16}, 1}\n\nExplicit column construction in this way allows adding comments to the column as well as controlling the storage manager and storage groups.","category":"section"},{"location":"#Implicit-construction","page":"Home","title":"Implicit construction","text":"Columns may also be added by simply assigning an array to your table where the type of the array will determine the type of the column. This will additionally populate the column with the contents of the array.\n\nFor example:\n\nsize(table) = (1000, 4)  # has 1,000 rows\n\ntable[:NEWCOL] = zeros(Int, 1000)::Vector{Int}\ntypeof(table[:NEWCOL]) <: Column{Int, 1}\n\ntable[:NEWCOL] = zeros(Int, 3, 1000)::Array{Int, 3}\ntypeof(table[:NEWCOL]) <: Column{Int, 3}\n\n# No fixed sized\ntable[:NEWCOL] = [rand(rand(UInt8, 2)...) for _ in 1:1000]::Vector{Matrix{Float64}}\ntypeof(table[:NEWCOL]) <: Column{Matrix{Float64}, 1}\n\n# No fixed dimension or size\ntable[:NEWCOL] = [rand(rand(UInt8, rand([1, 2, 3]))...) for _ in 1:1000]::Vector{Array{Float64}}\ntypeof(table[:NEWCOL]) <: Column{Array{Float64}, 1}\n\nNote that the table row length must match last dimension of the array being assigned.","category":"section"},{"location":"#Deletion","page":"Home","title":"Deletion","text":"Columns may be deleted using the delete!() function. For example:\n\ndelete!(table, :NEWCOL)","category":"section"},{"location":"#TaQL","page":"Home","title":"TaQL","text":"Casascore implements a query language that allows selecting, sorting, filtering and joining tables to produce derived tables, as described in Note 199. With the exception of CALC operations, this is available by calling taql(command, table1, [table2, ...]). For example:\n\nderived = taql(\n    raw\"SELECT max(ANTENNA1, ANTENNA2) as MAXANT FROM $1 WHERE ANTENNA1 <> ANTENNA2 AND NOT FLAG_ROW\",\n    table\n)\n\nsize(derived[:MAXANT]) == (228780,)\n\nCommand accepts a standard Julia String, however note that in this case we've prefixed the string with raw\"...\" which stops Julia attempting to interpolate the $1 table identifier. If you use a standard string literal, ensure such identifiers are properly escaped.","category":"section"},{"location":"#Casacore.Measures","page":"Home","title":"Casacore.Measures","text":"Measures allow constructing objects that contain a value with respect to a particular reference frame. Examples include: an Altitude/Azimuth frame with respect to a particular location and time on Earth; a Right Ascension/Declination on the sky with respect to the J2000 system; or a time in UTC timezone.\n\nIn Casacore, Measures are primarily implemented to allow conversions between types, and in Casacore.jl this is the primary use case for which we have designed their use.","category":"section"},{"location":"#Examples","page":"Home","title":"Examples","text":"An example converting a Direction from J2000 to local Aziumth/Elevation:\n\nusing Casacore.Measures\nusing Unitful  # provides @str_u macro for units, e.g. 1u\"m\"\n\n# We want to convert this RA/Dec direction to Azimuth/Elevation\ndirection = Measures.Direction(\n    Measures.Directions.J2000, 0u\"rad\", 0u\"rad\"\n)\n\n# A local Az/El requires knowledge of our position on Earth and the time\npos = Measures.Position(\n    Measures.Positions.ITRF, 5000u\"km\", 1000u\"km\", 100u\"km\"\n)\ntime = Measures.Epoch(Measures.Epochs.UTC, 1234567u\"d\")\n\n# Perform conversion by passing in desired type, as well as\n# any additional measures as a reference frame required for the conversion\n# newdirection = mconvert(newtype, olddirection, [measures...])\ndirection = mconvert(\n    Measures.Directions.AZEL, direction, pos, time\n)\n\ndirection.long, direction.lat  # -1.2469808464138252 rad, 0.48889373998953756 rad\n\nAn example converting a frequency from its REST frame to observed frequency based on additional information about its radial velocity:\n\n# Create radial velocity measure with a direction\ndirection = Measures.Direction(Measures.Directions.J2000, 45u\"°\", 20u\"°\")\n# Provide additional frame information for a measure as additional measures\n# during construction.\n# e.g. RadialVelocity(::Type, ::Unitful.Velocity, ::AbstractMeasure...)\nrv = Measures.RadialVelocity(\n    Measures.RadialVelocities.LSRD, 20_000u\"km/s\", direction\n)\n\nfreq = Measures.Frequency(\n    Measures.Frequencies.REST, 1420u\"MHz\", direction\n)\n\n# Now calculate the redshifted frequency\nfreqshifted = mconvert(Measures.Frequencies.LSRD, freq, rv)\nfreqshifted.freq  # 1328 MHz","category":"section"},{"location":"#Measure-Construction","page":"Home","title":"Measure Construction","text":"In general, a Measure is constructed in the following way\n\nMeasure(::Type, initval..., ::AbstractMeasures...; offset)\n\nHere the initval differs between specific Measures. For example, for Direction it consists two angle values; for Epoch it is a single time value. See below for full list.\n\nThe optional list of AbstractMeasures will be added as a reference frame for the Measure, and the optional offset can be entered as an origin point for the Measure. These concepts map directly to the underlying Casacore library.\n\nThe supported Measures and their properties are:\n\nMeasure Properties Quantity\nBaseline :x :y :z Unitful.Length\nDirection :long :lat Unitful.Angle\nDoppler :doppler Union{Float64, Unitful.Velocity}\nEarthMagnetic :x :y :z Unitful.Bfield\nEpoch :time Unitful.Time\nFrequency :freq Unitful.Frequency\nPosition :x :y :z Unitful.Length\nRadialVelocity velocity Unitful.Velocity\nUVW :u :v :w Unitful.Length\n\nAs an example, we might construct an EarthMagnetic vector in the following way:\n\n# Pass in each of x, y, z vector components in milli Tesla\nem = Measures.EarthMagnetic(\n    Measures.EarthMagnetics.AZEL, 1u\"mT\", 2u\"mT\", 3u\"mT\"\n)\n\nem.y == 0.002u\"T\"\n\nA more complicated example might be to provide a direction with respect to Jupiter at a particular time:\n\n# Set up frame\ntime = Measures.Epoch(Measures.Epochs.UTC, 60_000u\"d\")\n\n# Create Jupiter direction with addtional Epoch\njupiter = mconvert(\n    Measures.Directions.J2000,\n    Measures.Direction(Measures.Directions.JUPITER, 0u\"°\", 0u\"°\", time)\n)\n\n# Create direction offset from Jupiter\ndirection = Measures.Direction(\n    Measures.Directions.J2000, 5u\"°\", 10u\"°\"; offset=jupiter\n)","category":"section"},{"location":"#Conversions","page":"Home","title":"Conversions","text":"Conversions between types can be handled by the mconvert() function:\n\n# Direction conversions\nmconvert(\n    type::Directions.Types, dir::Direction, measures::AbstractMeasures...\n)\n\nThis will convert dir to the type type, with optional measures provided as part of the reference frame that might be necessary for the conversion.\n\nFor large numbers of conversions of the same type, using the same reference frame, it is recommended to reuse Measure and Conversion objects for maximal performance, as the construction of these objects has some overhead. This can be done using `mconvert!() which has the signature:\n\nmconvert!(in::T, out::T, c:Converter) where {T <: AbstractMeasure}\n\nFor example:\n\n\n# Set up 100,000 random RA/Dec coordinates to transform to AZEL\nradecs = rand(2, 100_000) * Unitful.rad\n\n# Reference frame\ntime = Measures.Epoch(Measures.Epochs.UTC, 60000u\"d\")\npos = Measures.Position(\n    Measures.Positions.ITRF, 6000u\"km\", 0u\"km\", 0u\"km\"\n)\n\n# Create conversion engine just once and reuse\n# Converter(in::type, out::type, measures::AbstractMeasures...)\nc = Measures.Converter(\n    Measures.Directions.J2000, Measures.Directions.AZEL, time, pos\n)\n\n# Create template direction which we will mutate for each conversion\ndir = zero(Measures.Direction)\n\nazels = map(eachcol(radecs)) do (ra, dec)\n    dir.type = Measures.Directions.J2000\n    dir.long = ra\n    dir.lat = dec\n    mconvert!(dir, dir, c)\n    return dir.long, dir.lat\nend","category":"section"},{"location":"#Observatories","page":"Home","title":"Observatories","text":"A limited set of observatories are known by Casacore and their positions can be loaded by name rather than explicitly providing coordinates.\n\nThe full list of known observatories can be queried:\n\nMeasures.Positions.observatories()\n\n# 47-element Vector{Symbol}:\n#  :ALMA\n#  :ARECIBO\n#  ⋮\n#  :MWA32T\n#  Symbol(\"AMI-LA\")\n\nAn observatory position can be constructed using the observatory name:\n\nobs1 = Measures.Position(:ALMA)\n# Position(:type=WGS84, :x=1761.86 m, :y=-4307.63 m, :z=-1977.70 m)\n\nobs2 = Measures.Position(:ATCA)\n# Position(:type=ITRF, :x=-4.75091e6 m, :y=2.79290e6 m, :z=-3.20048e6 m)","category":"section"},{"location":"#Casacore.LibCasacore","page":"Home","title":"Casacore.LibCasacore","text":"All objects and methods that are exposed by CxxWrap are available in LibCasacore. This is not a stable API and may be subject to change.","category":"section"}]
}
